# task_test
____
## Подготовка БД
Выбрана БД MySQL и метод запуска mysql-сервера в контейнере.
Для этого необходимо использовать команду:

`sudo docker run --rm -d -e MYSQL_ROOT_PASSWORD=pass -p 3307:3306 --name mysql_test mysql:5.7`

Далее необходимо загрузить готовый шаблон БД со всеми необходимыми таблицами из файла `mysql_db.sql` с помощью команды:

`mysql -uroot -ppass -h127.0.0.1 -P3307 < "путь до файла mysql_db.sql"` например `< /home/vlad/my/vito/mysql_db.sql`

**Данная БД имеет 4 таблицы:**  
 *Users - хранит: id и баланс пользователей,  
  Services - хранит сведения об услугах: id услуги и цену,  
  Reservation - сведения о транзакции: id пользователя, id услуги, id заказа и сумму (после подтверждения/отказа запись удаляется),   
  Report - хранит сведения о подтвержденных транзакциях (для бухгалетрии) : id пользователя, сумму, id услуги и id заказа;*  

____
## Запуск проекта
После подготовки и запуска БД можно перейти к запуску проекта:    
 -клонируйте репозиторий `git clone https://github.com/Oddi17/test_task`   
 -создайте докер-контейнер `sudo docker build -t golang-api .`  
 -запустите докер-контейнер `sudo docker run -p 8000:3307 golang-api`  
 

## Запросы  
*Для тестирования запросов использовался* `curl`
### Метод начисления средств на баланс. Принимает id пользователя и сколько средств зачислить.  
### Метод `POST`  
#### Создает баланс пользователя, если такого еще не существует:  
#### Запрос в json-форматe:
```
curl -X POST -H "Content-Type: application/json" -d '{"id": 2, "balance": 1}' http://172.17.0.1:8000/AddUserBalance
```
#### Ответ запроса в json-форматe:
```
{"message":"successfully completed! user id:2 ; balance:1000.00 "}
```
#### Если данный пользователь уже существует, то просто пополняется его баланс:
#### Запрос в json-форматe:  
```
curl -X POST -H "Content-Type: application/json" -d '{"id": 2, "balance": 500}' http://172.17.0.1:8000/AddUserBalance
```
#### Ответ запроса в json-форматe:  
```
{"message":"successfully completed! user id:2 ; balance:1500.00 "}
```
____
### Метод получения баланса пользователя. Принимает id пользователя. Принимает id пользователя в шапке запроса (с учетом игнорирования тела запроса у метода GET):  
### Метод `GET`  
#### Запрос:    
```
curl http://172.17.0.1:8000/UserBalance/2
```
#### Ответ запроса в json-форматe:  
```
{"id":2,"balance":502}
```
____
### :pencil2: Примечание к последующим методам:  
#### Т.к. не особо понятно как происходило бы признание транзакции было принято решение, что на этапе резервирования будет проводится проверка достаточно ли средств на услугу, в противном случае будет отправлено соответствующее уведомление и резервирование не произойдет.  
#### На следующем этапе признания/отказа транзакции было принято решения добавить пока что возможность ручного принятия или отказа транзакции:   
#### *Принятие -> списание денег из резерва и отправка в отчет*  
#### *Отказ -> деньги возвращаются на счет пользователя*  
____
### Метод резервирования средств с основного баланса на отдельном счете. Принимает id пользователя, ИД услуги. Стоимость берется из таблицы услуг `Services`, ИД заказа формируется посредством инкремента в таблице.  
### Метод `PUT` 
#### Запрос в json-форматe:   
```
curl -X PUT -H "Content-Type: application/json" -d '{"id_user": 2, "id_service": 1}' http://172.17.0.1:8000/Transaction
```
#### Ответ запроса в json-форматe (* в данном случае id_service соответствует стоимость 999*):    
```
{"message":"Successfully reserved! id:2 current balance:501.00 "}
```
#### Недостаточно средств у пользователя:  
##### Запрос в json-форматe:  
```
curl -X PUT -H "Content-Type: application/json" -d '{"id_user": 1, "id_service": 1}' http://172.17.0.1:8000/Transaction
```
##### Ответ запроса в json-форматe:   
```
{"message":"Error : insufficient funds"}
```
### Метод признания выручки – списывает из резерва деньги, добавляет данные в отчет для бухгалтерии. Принимает id пользователя, ИД заказа (из таблицы `Reservation`) 
### Метод `POST`
#### Запрос в json-форматe:
```
curl -X POST -H "Content-Type: application/json" -d '{"id_user": 2, "id_order": 6}' http://172.17.0.1:8000/TransactionConfirm
```
#### Ответ запроса в json-форматe:  
```
{"message":"Transaction of order:6 was confirmed! "}
```

### Метод отказа транзакции – возвращает зарезервированные деньги пользователю, в отчет данная транзакция не идет. Принимает id пользователя, ИД заказа (из таблицы `Reservation`)  
### Метод `PUT`    
#### Запрос в json-форматe:    
```
curl -X PUT -H "Content-Type: application/json" -d '{"id_user": 2, "id_order": 5}' http://172.17.0.1:8000/TransactionReject
```
#### Ответ запроса в json-форматe:  
```
{"message":"Transaction of order:5 was rejected! "}
```
____
### :clipboard: Итог и учет ошибок:
Я впервые делаю нечто подобное - работа с данным фреймворком Gin и БД MySQL.Разработка проекта Rest API, и тем более на GO, была довольно масштабная задача для меня, но считаю успехом то, что я в итоге справился с этим за такой короткий промежуток времени!    
####Что следует учесть для дальнейшего развития:  
1. Стоит правильно выбирать инструменты для создания проекта - отстутсвие опыта и выбор данного фреймворка потребовали дополнительного времени на разработку, в следствии чего не успел добраться до функции "отправки денег от пользователи к пользователю" и реализации соответствующих тестов, ну и конечно же дополнительных заданий.  
2. Необходимо рассчитывать время и силы. Нехватка опыта привела к пути реализации проекта "как сам понимаю", ограничение времени не позволило учесть правильную архитектуру кода для такого вида микросервисов.
3. Практиковаться и практиковаться)   


